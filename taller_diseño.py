# -*- coding: utf-8 -*-
"""Taller diseño

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CfLWpaTl2ESgGwzv7_h3escZblValV4J
"""

from scipy.stats import shapiro
import mpl_toolkits
import numpy as np
import matplotlib.pyplot as plt
import folium
import pandas as pd
import numpy as np
from random import sample
import seaborn as sns
import random as rd
import scipy as sc 
import folium
from matplotlib.lines import Line2D
from folium.map import Popup
from matplotlib import style
import seaborn as sns
import statsmodels.api as sm
from mpl_toolkits import mplot3d
import plotly.express as px
from scipy.spatial import distance_matrix

"""**Integrantes:**

*   Yuly Natalia Melgarejo Cuevas 
*   Sergio Nicolas Cepeda Rodriguez

## **Asignación: Diseño de Experimentos/ Práctica Python**

El siguiente conjunto de datos agronómicos permite usar la misma entrada para ajustar diferentes modelos haciendo uso esta vez del programa Python usando cualquier plataforma. 

La matriz de datos contiene las variables

y: Latitud

x: Longitud

SMI: Índice de humedad del suelo

NDVI: Indice de vegetación de diferencia normalizado

LST: Temperatura en la superficie del suelo

**1. Convertir el código R en Python para generar un data.frame de manera análoga**
"""

import random
random.seed(1006944258)
seqlat = np.arange(-73.30, -73.25, 0.001)
seqlong = np.arange(5.54, 5.58, 0.001)
latitude = np.random.choice(seqlat, size=100, replace=True)
longitude = np.random.choice(seqlong, size=100, replace=True)

data = {
  "x": longitude,
  "y": latitude
}
xy = pd.DataFrame(data)
print(xy)

xy.plot(kind = 'scatter',
        x = 'x',
        y = 'y',
        color = 'red')

plt.title('Grafico')
  
plt.show()

SMI = np.partition(np.random.uniform(0.7,0.95,100), 10)
NDVI = np.partition(np.random.uniform(0.45,0.06,100), 10)
LST = np.partition(26* sc.stats.beta.rvs(0.87,0.91, size=100), 10)

"""**2. Graficar la nube de puntos (solo coordenadas)**"""

xy.plot(kind = 'scatter',
        x = 'x',
        y = 'y',
        color = 'green')

plt.title('Grafico')
  
plt.show()

"""**3. Asignar al gráfico un tamaño al punto de acuerdo con el SMI (graficar)**"""

df = pd.DataFrame({'lat' : latitude, 'lon': longitude, 'smi': SMI, 'lst':LST,'ndvi':NDVI })
sns.relplot(x="lon", y="lat", size="smi", color='green', data=df)

"""*   El índice de humedad del suelo no parece ser alto o bajo en un área en particular, por el contrario es muy variable.

**4. Asignar al gráfico un color al punto de acuerdo con el NDVI (graficar)**
"""

sns.relplot(x="lon", y="lat", hue="ndvi", palette="ch:r=-.5,l=.75", data=df)

"""*   El índice de vegetación de diferencia normalizado no parece ser alto o bajo en un área en particular.

**5. Asignar al gráfico una forma al punto de acuerdo con el LST(graficar)**
"""

chars = "QWERTYUIOPASDFGHJKLÑZXCVBNMqwertyuiopasdfghjklñzxcvbnm"
form = []

for j in range(100):
  form.append('$'+random.choice(chars)+'$')

for i in range (len(df['lon'])):
  plt.scatter(df['lon'][i], df['lat'][i], marker=form[i])
plt.show()

sns.scatterplot(data=df, x="lon", y="lat",  style="lst", legend = False)

"""**6. Buscar alguna librería o programa (en última opción) que permita visualizar los puntos en el mapa de Colombia (¿están todos los puntos en Colombia? ¿pertenecen los puntos a alguna región específica de Colombia? ¿están todos los puntos dentro de esa región? Si alguno se sale de esa región (departamento), decartarlo y volver a graficar.**"""

Map = folium.Map(location= [4.570868, -74.297333],zoom_start=6)
for i in range(len(df['lat'])):
  folium.Marker(
      location= [df['lon'][i],df['lat'][i]],
      popup=f"lon:{df['lon'][i]}, lat:{df['lat'][i]}" ,
      icon= folium.Icon()
      ).add_to(Map) 
Map

"""*   Todos los puntos están dentro de Colombia, en los alrededores de Chivata obre el altiplano Cundiboyacense.

**7. Realice un boxplot para SMI**
"""

df2 = pd.DataFrame({ 'ndvi':NDVI,'smi': SMI, 'lts':LST })

plt.boxplot(SMI)
plt.ylabel('SMI',fontsize=10)
plt.show()

"""*   No se muestran datos atípicos

**8. Realice un histograma para NDVI**
"""

plt.hist(NDVI, bins=50)
plt.xlabel('NDVI',fontsize=10)
plt.ylabel('Frecuencia',fontsize=10)
plt.show()

"""*   La forma del histograma se asemeja a la de una distribución asimétrica negativa, sin embargo en muchas partes de esta se conserva cierta uniformidad.

**9. Grafique la densidad para LST**
"""

df.lst.plot.density(color='green')
plt.title('Densidad para LST')
plt.show()

"""**10. Calcule estadísticas descriptivas para las 3 variables**"""

df2.describe()

"""*   En este caso no se pueden comparar las medias debido a que son variables diferentes. A diferencia de los índices, la temperatura en la superficie del suelo toma valores mas grandes por la naturaleza misma de la medida.

**11. Fracciones los datos de latitud en 4 cuadrantes y etiquete los puntos como (I,II,II y IV) según el cuadrante y cree esta nueva variable(cuadrante como tipo factor o cadena) y calcule las estadísticas descriptivas por cuadrante**
"""

lonmedia = np.mean(xy['x'])
latmedia = np.mean(xy['y'])
plt.axvline(x=lonmedia, color="red", linestyle="--")
plt.axhline(y=latmedia, color="black", linestyle="--")
plt.plot(xy['x'], xy['y'], 'bo')
plt.show()

print(lonmedia)
print(latmedia)

conditions = [
    (xy['x'] > lonmedia) & (xy['y'] > latmedia),
    (xy['x'] < lonmedia) & (xy['y'] > latmedia),
    (xy['x'] < lonmedia) & (xy['y'] < latmedia),
    (xy['x'] > lonmedia) & (xy['y'] < latmedia)
    ]

fac = ['I', 'II', 'III', 'IV']

xy['factor'] = np.select(conditions, fac)

xy['smi']= SMI
xy['ndvi']= NDVI
xy['lst']= LST

print(xy)

xy.groupby('factor').describe()

"""*   Hay mas puntos muestreados en el cuadrante IV.
*   En el cuadrante II los datos de indice de humedad en le suelo tienden a estar mas cerca de su media.

**12. Realice un boxplot para SMI que muestre las cajas de los 4 cuadrantes en el mismo gráfico**
"""

sns.boxplot(data=xy, x='factor', y='smi')
plt.ylabel('SMI')
plt.xlabel('Factor')
plt.title('Diagrama de cajas')
plt.show()

"""**13. Realice un histograma múltiple para NDVI que los muestre para los 4 cuadrantes en el mismo gráfico (superponiendo los histogramas)**"""

xy.groupby('factor')
sns.histplot(data=xy,x="ndvi", hue="factor")

"""**14. Realice un gráfico de densidades múltiple para LST que los muestre para los 4 cuadrantes en el mismo gráfico (superponiendo las densidades)**"""

df5=xy.pivot(columns='factor', values='lst') 

df5.plot.density(figsize = (7, 7), 
                       linewidth = 4)

"""**15. Construya una matriz de correlaciones de Pearson para las 5 variables**"""

df6=pd.DataFrame({'lat' : latitude, 'lon': longitude,  'lst':LST ,'smi': SMI,'ndvi':NDVI })
df6.corr()
corr= df6.corr ()
corr.style.background_gradient (cmap = 'coolwarm')

"""Correlación positiva: Las variables se mueven en la misma dirección

correlación negativa: Las variables se mueven en la dirección opuesta

**16. Realice un grafico  de correlaciones para las 5 variables**
"""

pd.plotting.scatter_matrix(df6)

sns.regplot(x=df6["lon"], y=df6["lat"], line_kws={"color":"r","alpha":0.7,"lw":5})

"""**17. Fraccione el gráfico de correlaciones por cuadrante y muestre las 4 figuras en un solo gráfico**

"""

sns.lmplot(x="x", y="y", hue="factor", data=xy)

"""**18. Ajuste algún modelo de regresión lineal simple entre el NDVI (respuesta) y el LST**"""

y = xy['ndvi'] # variable dependiente
x = xy['lst'] # variable independiente 
X = sm.add_constant(x)
lm = (sm.OLS(y, X)).fit()
model_summary=lm.summary()  
print(model_summary)

"""El R-squared nos indica un bajo ajuste del modelo a la variable ndvi

**19. Ajuste un modelo de regresión multiple entre NDVI (respuesta) con  LST y SMI**
"""

y = xy['ndvi'] # variable dependiente
x = xy[{'lst',"smi"}] # variable independiente 
X = sm.add_constant(x)
lm = (sm.OLS(y, X)).fit()
model_summary=lm.summary()  
print(model_summary)

"""El R-squared nos indica un mejor ajuste del modelo.

**20. Tome una muestra del 80% del data.frame y calcule la matriz de correlaciones por cuadrante. Compare con el caso de todos los datos.**
"""

muestra_xy = df.sample(80)
print(muestra_xy )

muestra_xy.corr()
mc= muestra_xy.corr ()
mc.style.background_gradient (cmap = 'coolwarm')

"""Correlación positiva: Las variables se mueven en la misma dirección

correlación negativa: Las variables se mueven en la dirección opuesta

**21. Haga un gráfico 3D para las 3 variables ambientales**
"""

f = px.scatter_3d(xy, x = 'smi', 
                    y = 'ndvi', 
                    z = 'lst')
  
f.show()

"""**22. Haga un gráfico 3D para las 3 variables ambientales y asigne color según cuadrante**"""

fig = px.scatter_3d(xy, x = 'smi', 
                    y = 'ndvi', 
                    z = 'lst',
                    color = 'factor')
  
fig.show()

"""**23. Investigue como se construye una matriz de distancias entre todos las coordenadas**"""

m = np.stack([xy['x'],xy['y']], axis=1)
mm=distance_matrix(m, m)
print(mm)

np.amax(mm)

0.05661271941905754/3

0.01887090647301918+0.01887090647301918

"""**24. Ubique el centroide de toda la nube de puntos de coordenadas y seleccione solo puntos en una ventana de radio a lo sumo igual a 2/3 de la máxima distancia en la matriz de distancias**"""

data= np.array(m)
def centroid(array):
  length=array.shape[0]
  sum_x =np.sum(array[:,0])
  sum_y =np.sum(array[:,1])
  return sum_x /length ,sum_y/length

centroide = centroid(data)
print(centroide)
plt.plot(xy['x'],xy['y'],'bo')
plt.scatter(centroide[0],centroide[1],c="r")

"""**25. Calcule estadísticas descriptivas en esta ventana circular (dibuje la ventana) y asigne un color diferente a los puntos dentro de esta ventana**"""

centroide = centroid(data)
print(centroide)
circle = plt.Circle((centroide), 0.01, color='y')
fig, ax = plt.subplots()
ax.add_patch(circle)

plt.plot(xy['x'],xy['y'],'bo')
plt.scatter(centroide[0],centroide[1],c="r")

des=xy.describe()
print(des)

"""**26.  Suponga que queremos hacer un análisis de varianza para comparar la media de SMI por cuadrante. Se pide primero tomar aleatoriamente 10 datos de cada cuadrante y construir un nuevo data.frame con todas las variables pero solo con 40 filas. Utilice el análisis de varianza (modulo pingouin si desea) para comparar el índice medio de los 4 cuadrantes.**

"""

import statsmodels.api as sm
from statsmodels.formula.api import ols
mod= ols("smi ~ factor" ,data=dx3).fit()
aov_table=sm.stats.anova_lm(mod,typ=2)
print(aov_table)

"""**27. Use alguna librería que permita extraer los residuales del modelo y haga su histograma**"""

resu=mod.resid
print(resu)

pyplot.hist(resu)
 pyplot.show()

"""**28. Utilice la prueba de Shapiro para probar normalidad en los residuales**"""

# normality test
stat, p = shapiro(resu)
print('Statistics=%.3f, p=%.3f' % (stat, p))
# interpret
alpha = 0.05
if p > alpha:
	print('Sample looks Gaussian (fail to reject H0)')
else:
	print('Sample does not look Gaussian (reject H0)')

"""No rechazamos la hipótesis nula, suponemos que los residuos se distribuyen normalmente

**29. Utilice la prueba de Levine para probar igualdad de varianzas de los residuales**
"""

!pip install bioinfokit

from bioinfokit.analys import stat

res = stat()
res.anova_stat(df=dx3, res_var='smi', anova_model='smi ~ C(factor)')
res.anova_summary

res = stat()
res.levene(df=dx3, res_var='smi', xfac_var='factor')
res.levene_summary

"""No se rechaza la hipotesis nula, suponemos varianzas iguales

**30. Investigue como se calcula el índice de Moran y pruebe si los residuales muestran dependencia atribuible a la autocorrelación espacial entre ellos.**
"""

dx6=pd.merge(dx5,resu,how='outer' )

gdf = gpd.read_file()
y = gdf['Donatns'].values
w = Queen.from_dataframe(gdf)
w.transform = 'r'
from esda.moran import Moran
w = Queen.from_dataframe(gdf)
moran = Moran(y, w)
moran.I